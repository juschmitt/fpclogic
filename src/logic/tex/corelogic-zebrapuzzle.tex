\section{Einstein-Test oder Zebrapuzzle}

Bei diesem R"atsel geht es darum, aus einer Menge von 5 Personen, die sich alle jeweils durch die Farbe ihres Hauses, ihr Getr"ank, irh Haustier, ihre Zigarettenmarke und ihre Nationalit"at unterscheiden, mithilfe von gegebenen Informationen und einem logischen L"osungsansatz, genau eine Person mit einer gewissen Eigenschaft herauszufinden. N"aheres z.B. auf Wikipedia.

\subsection{Code}

Das entsprechendes Codebeispiel kann auf folgender Seite \url{https://github.com/swannodette/logic-tutorial#zebras} gefunden werden.


Nachfolgend werden die im Codebeispiel definierten Methoden erkl"art.

\subsubsection{righto}

\begin{lstlisting}
(defne righto [x y l]
  ([_ _ [x y . ?r]])
  ([_ _ [_ . ?r]] (righto x y ?r)))
\end{lstlisting}

Diese Methode erzeugt alle Beschr"ankungen, die wir ben"otigen damit \dq{}y\dq{} rechts von \dq{}x\dq{} steht. Ein rekursiver Aufruf sorgt st"o\ss{}t den Prozess so oft wieder an bis der Rest, dargstellt durch das \code{?r} behandelt wurde. Genauer werden also die Constraints zur"uckgegeben, oder auch Goals, die der Solver ben"otigt um unser Ergebnis zu errechnen.

\subsubsection{nexto}

\begin{lstlisting}
(defn nexto [x y 1]
  (conde
    ((righto x y 1))
    ((righto y x 1))))
\end{lstlisting}

Diese Methode erzeugt Pr"adikate um alle Permutationen eines Objektes zu bekommen, wenn es sich daneben befindet. Auch hier reden wir bei der R"uckgabe wieder von Constraints/Goals.

\subsubsection{zebrao}

\begin{lstlisting}
(defn zebrao [hs]
  (macro/symbol-macrolet [_ (lvar)]
    (all
     (== [_ _ [_ _ 'milk _ _] _ _] hs)
     (firsto hs ['norwegian _ _ _ _])
     (nexto ['norwegian _ _ _ _] [_ _ _ _ 'blue] hs)
     (righto [_ _ _ _ 'ivory] [_ _ _ _ 'green] hs)
     (membero ['englishman _ _ _ 'red] hs)
     (membero [_ 'kools _ _ 'yellow] hs)
     (membero ['spaniard _ _ 'dog _] hs)
     (membero [_ _ 'coffee _ 'green] hs)
     (membero ['ukrainian _ 'tea _ _] hs)
     (membero [_ 'lucky-strikes 'oj _ _] hs)
     (membero ['japanese 'parliaments _ _ _] hs)
     (membero [_ 'oldgolds _ 'snails _] hs)
     (nexto [_ _ _ 'horse _] [_ 'kools _ _ _] hs)
     (nexto [_ _ _ 'fox _] [_ 'chesterfields _ _ _] hs))))
\end{lstlisting}

Die f"unf H"auser mit jeweils einer Person und deren f"unf verschiedene Eigenschaften, werden intern durch eine Matrix dargestellt. Ein Vektor der Gr"o\ss{}e f"unf f"ur die Darstellung der H"auser, und jeweils f"ur jedes Haus ein Vektor der Gr"o\ss{}e f"unf. Ein \dq{}Haus-Vektor\dq{} hat dabei folgende Bedeutung:
\\
\\
\code{['Nationalit"at' 'Zigarettenmarke' 'Getr\"ank' 'Haustier' 'Hausfarbe']}
\\
\\
Diese Methode enth"alt s"amtliche Regeln des Puzzles. Durch die Wahl von sprechenden Namen, der verwendeten und selbst definierten Methoden, sind die Regeln sehr gut abzulesen. Die erste Zeile enth"alt z.B. zwei Regeln. Einmal die Regel, das es f"unf H"auser gibt und die Regel, das die Person im mittleren Haus trinkt Milch trinkt. Die zweite Regel sagt aus, das die Person ganz links (firsto, "der Erste") norwegisch ist. Die Dritte, das neben der norwegischen Person ein blaues Haus steht und so weiter.
Im Programmcode werden in der zweiten Zeile die Zeichen \dq{}lvar\dq{} an das Symbol \dq{}\_\dq{} gebunden. Das erspart einige Zeichen Code und erh"oht die Lesbarkeit.
