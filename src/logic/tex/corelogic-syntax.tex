\section{Syntax}

In diesem Kapitel soll die allgemeine Syntax von core.logic, die wichtigsten Funktionen und einige weiterführenden Funktionen vorgestellt werden. Weiterhin werden tiefergreifende Features vorgestellt und erklärt.

\subsection{Allgemeines}

Wie bereits in dem vorhergehenden Kapitel an einigen Beispielen zu sehen war, hat core.logic eine signifikante Syntax.
\begin{lstlisting}
(run * [logic-variables] (logic-expressions in conjunction))
\end{lstlisting}
Dieser Ausdruck liest sich wie folgt: ''Nimm die logischen Ausdrücke, lass den Solver diese lösen und gib alle Werte der logischen Variblen zurück die diese Ausdrücke erfüllen.''\\

Um nicht bei jedem Aufruf der \code{run} Funktion alle Werte der logischen Variable zu bekommen, sondern nur endlich viele, kann man den * nach \code{run} durch eine Zahl ersetzen die der Anzahl der Werte entspricht die zurück gegeben werden sollen.


\subsection{Wichtige Funktionen}

core.logic basiert, "ahnlich wie miniKanren, auf 3 grundlegenden Funktionen.
\begin{description}
\item{\code{fresh}:}
Mit fresh lassen sich beliebig viele neue logische Variablen ins Programm einf"uhren. Variablen die durch fresh eingef"uhrt wurden, sind auch nur innerhalb von diesem g"ultig, d.h. lvars innerhalb von fresh m"ussen auf eine au\ss{}erhalb von fresh g"ultige lvar "ubertragen werden.

\item{\code{unify}:}
unify setzt lvars gleich. Entweder zu anderen lvars oder zu Werten. Mit unify lassen sich so zB lvars innerhalb von fresh auf eine lvar au\ss{}erhalb von fresh "ubetragen.

\item{\code{conde}:}
Mit conde ("ahnlich zu cond aus dem clojure.core Paket) lassen sich Constraints so gesagt \dq{}verodern\dq{}. Das heißt es erzeugt eine logische Disjunktion von Constraints.
\end{description}

Beispiel für \code{conde}:
\begin{lstlisting}
(run* [q]
    (conde
        ((unify q 2))
	  *OR*
        ((unify q 1) *AND* (unify q q))
	  *OR*
	((fresh [r s] 
	  (unify r 1)
	    *AND*
	  (unify s 2)
	    *AND*
	  (unify r q)
	    *AND*
	  (unify s q))
)
\end{lstlisting}

Das sind die 3 grundlegenden Funktionen von core.logic. Das gesamte Package beinhaltet aber nat"urlich noch viele mehr, Wie z.B. das eben gesehene (membero \dots{}). Alle weiteren Funktionen im Package bauen aber auf den 3 Basis Funktionen auf. H"ohere Funktionen, folgen einer bestimmten Namenskonvention, wie z.B. zu sehen bei conde und memebero, werden Funktionen in core.logic die schon im clojure.core existieren mit einem a,e,u oder o um diese von den regul"aren clojure Funktionen zu differenzieren und diese nicht zu "uberschreiben.

Ein nachgestelltes 
\begin{itemize}
  \item a steht f"ur 
  
  \item e steht f"ur 
  
  \item u steht f"ur 
  
  \item o steht f"ur die R"uckgabe von Goals bzw. einer Relation

\end{itemize}

\subsection{Aufruf der Instanz eines L"osungsautomaten oder auch Solver}

\begin{lstlisting}
    (run* [logic-variable] &constraints)
\end{lstlisting}


Tafelbild: (run* [q] (== 1 q) ) ; R"uckgabe --> 1
(run* \dots{}) -> Befehl f"ur den Solver; * ist Anzahl der Ergebnisse, kann auch entsprechend eine Zahl sein.
[q] -> ist die logische Variable für die ein oder mehrere Werte gesucht wird
(== 1 q) -> ist die Beschr"ankung für q.
\dq{}Gib alle Werte für q zur"uck für die gilt: q == 1\dq{}
