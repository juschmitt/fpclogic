\subsection{Syntax}

\subsubsection{Allgemeines}



\subsubsection{Wichtige Funktionen}

core.logic basiert, "ahnlich wie miniKanren, auf 3 grundlegenden Funktionen.

fresh:
Mit fresh lassen sich beliebig viele neue logische Variablen ins Programm einf"uhren. Variablen die durch fresh eingef"uhrt wurden, sind auch nur innerhalb von diesem g"ultig, d.h. lvars innerhalb von fresh müssen auf eine außerhalb von fresh g"ultige lvar "ubertragen werden.

unify:
unify setzt lvars gleich. Entweder zu anderen lvars oder zu Werten. Mit unify lassen sich so zB lvars innerhalb von fresh auf eine lvar außerhalb von fresh "ubetragen.

conde:
Mit conde ("ahnlich zu cond aus dem clojure.core Paket) lassen sich Constraints so gesagt “verodern”. dh es erzeugt eine logische Disjunktion von Constraints.

Beispiel:
\begin{lstlisting}
(run* [q]
    (conde
        ((unify q 2))
	  *OR*
        ((unify q 1) *AND* (unify q q))
	  *OR*
	((fresh [r s] 
	  (unify r 1)
	    *AND*
	  (unify s 2)
	    *AND*
	  (unify r q)
	    *AND*
	  (unify s q))
)
\end{lstlisting}

Das sind die 3 grundlegenden Funktionen von core.logic. Das gesamte Package beinhaltet aber natürlich noch viele mehr, Wie z.B. das eben gesehene (membero …). Alle weiteren Funktionen im Package bauen aber auf den 3 Basis Funktionen auf. H"ohere Funktionen, folgen einer bestimmten Namenskonvention, wie z.B. zu sehen bei conde und memebero, werden Funktionen in core.logic die schon im clojure.core existieren mit einem a,e,u oder o um diese von den regulären clojure Funktionen zu differenzieren und diese eventuell nicht zu überschreiben.

Ein nachgestelltes 
\begin{itemize}
  \item a steht für 
  
  \item e steht für 
  
  \item u steht für 
  
  \item o steht für die Rückgabe von Goals bzw. einer Relation

\end{itemize}

\subsubsection{Aufruf der Instanz eines Lösungsautomaten oder auch Solver}

\begin{lstlisting}
    (run* [logic-variable] &constraints)
\end{lstlisting}


Tafelbild: (run* [q] (== 1 q) ) ; Rückgabe --> 1
(run* ...) -> Befehl für den Solver; * ist Anzahl der Ergebnisse, kann auch entsprechend eine Zahl sein.
[q] -> ist die logische Variable für die ein oder mehrere Werte gesucht wird
(== 1 q) -> ist die Beschränkung für q.
“Gib alle Werte für q zurück für die gilt: q == 1”
